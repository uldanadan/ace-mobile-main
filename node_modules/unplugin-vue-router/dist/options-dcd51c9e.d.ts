import { RouteRecordRaw } from 'vue-router';

interface CustomRouteBlock extends Partial<Omit<RouteRecordRaw, 'components' | 'component' | 'children' | 'beforeEnter' | 'name'>> {
    name?: string;
}

declare const enum TreeNodeType {
    static = 0,
    param = 1
}
interface RouteRecordOverride extends Partial<Pick<RouteRecordRaw, 'meta' | 'props' | 'alias' | 'path'>> {
    name?: string;
}
declare type SubSegment = string | TreeRouteParam;
declare class _TreeNodeValueBase {
    /**
     * flag based on the type of the segment
     */
    _type: TreeNodeType;
    /**
     * segment as defined by the file structure
     */
    rawSegment: string;
    /**
     * transformed version of the segment into a vue-router path
     */
    pathSegment: string;
    /**
     * Array of sub segments. This is usually one single elements but can have more for paths like `prefix-[param]-end.vue`
     */
    subSegments: SubSegment[];
    /**
     * fullPath of the node based on parent nodes
     */
    path: string;
    /**
     * Overrides defined by each file. The map is necessary to handle named views.
     */
    private _overrides;
    /**
     * Should this add the loader guard in the route record.
     */
    includeLoaderGuard: boolean;
    /**
     * Component path that maps to a view name, which is used for vue-router's named view feature.
     * Use `default` key for the default view.
     */
    filePaths: Map<string, string>;
    constructor(rawSegment: string, parent: TreeNodeValue | undefined, pathSegment?: string, subSegments?: SubSegment[]);
    toString(): string;
    isParam(): this is TreeNodeValueParam;
    isStatic(): this is TreeNodeValueStatic;
    get overrides(): RouteRecordOverride;
    setOverride(path: string, routeBlock: CustomRouteBlock | undefined): void;
}
declare class TreeNodeValueStatic extends _TreeNodeValueBase {
    _type: TreeNodeType.static;
    constructor(rawSegment: string, parent: TreeNodeValue | undefined, pathSegment?: string);
}
interface TreeRouteParam {
    paramName: string;
    modifier: string;
    optional: boolean;
    repeatable: boolean;
    isSplat: boolean;
}
declare class TreeNodeValueParam extends _TreeNodeValueBase {
    params: TreeRouteParam[];
    _type: TreeNodeType.param;
    constructor(rawSegment: string, parent: TreeNodeValue | undefined, params: TreeRouteParam[], pathSegment: string, subSegments: SubSegment[]);
}
declare type TreeNodeValue = TreeNodeValueStatic | TreeNodeValueParam;
declare function createTreeNodeValue(segment: string, parent?: TreeNodeValue): TreeNodeValue;

declare class TreeNode {
    /**
     * value of the node
     */
    value: TreeNodeValue;
    /**
     * children of the node
     */
    children: Map<string, TreeNode>;
    /**
     * Parent node.
     */
    parent?: TreeNode;
    /**
     * Plugin options taken into account by the tree.
     */
    options: ResolvedOptions;
    /**
     * Should this page import the page info
     */
    hasDefinePage: boolean;
    constructor(options: ResolvedOptions, filePath: string, parent?: TreeNode);
    /**
     * Adds a path to the tree. `path` cannot start with a `/`.
     *
     * @param path - route path segment to insert
     * @param filePath - file path, defaults to path for convenience and testing
     */
    insert(path: string, filePath?: string): TreeNode;
    setCustomRouteBlock(path: string, routeBlock: CustomRouteBlock | undefined): void;
    getSortedChildren(): TreeNode[];
    /**
     * Remove a route from the tree.
     *
     * @param path - file path of the file
     */
    remove(path: string): void;
    /**
     * Returns the route path of the node without parent paths.
     */
    get path(): string;
    /**
     * Returns the route path of the node including parent paths.
     */
    get fullPath(): string;
    get name(): string;
    get meta(): string;
    get params(): TreeRouteParam[];
    isRoot(): boolean;
    toString(): string;
}
declare function createPrefixTree(options: ResolvedOptions): TreeNode;

interface RoutesFolderOption {
    src: string;
    path?: string;
}
declare type _RoutesFolder = string | RoutesFolderOption;
declare type RoutesFolder = _RoutesFolder[] | _RoutesFolder;
interface ResolvedOptions {
    /**
     * Extensions of files to be considered as pages. Defaults to `['.vue']`. Cannot be empty.
     */
    extensions: string[];
    /**
     * Folder containing the components that should be used for routes. Can also be an array if you want to add multiple
     * folders, or an object if you want to define a route prefix. Supports glob patterns but must be a folder, use
     * `extensions` and `exclude` to filter files.
     *
     * @default "src/pages"
     */
    routesFolder: RoutesFolderOption[];
    /**
     * Method to generate the name of a route.
     */
    getRouteName: (node: TreeNode) => string;
    /**
     * Enables EXPERIMENTAL data fetching. See https://github.com/posva/unplugin-vue-router/tree/main/src/data-fetching
     */
    dataFetching: boolean;
    /**
     * Defines how page components should be imported. Defaults to dynamic imports to enable lazy loading of pages.
     */
    importMode: _OptionsImportMode;
    /**
     * Array of file globs to ignore. Defaults to `[]`.
     */
    exclude: string[];
    /**
     * Root of the project. All paths are resolved relatively to this one. Defaults to `process.cwd()`.
     */
    root: string;
    /**
     * Language for `<route>` blocks in SFC files. Defaults to `'json5'`.
     */
    routeBlockLang: string;
    /**
     * Should generate d.ts files. Defaults to `true` if `typescript` is installed.
     */
    dts: boolean | string;
    /**
     * Allows inspection by vite-plugin-inspect by not adding the leading `\0` to the id of virtual modules.
     * @internal
     */
    _inspect: boolean;
    /**
     * Activates debug logs.
     */
    logs: boolean;
}
/**
 * @internal
 */
declare type _OptionsImportMode = 'sync' | 'async' | ((filepath: string) => 'sync' | 'async');
interface Options extends Partial<Omit<ResolvedOptions, 'routesFolder'>> {
    routesFolder?: RoutesFolder;
}
declare const DEFAULT_OPTIONS: ResolvedOptions;
interface ServerContext {
    invalidate: (module: string) => void;
    reload: () => void;
}
/**
 * Normalize user options with defaults and resolved paths.
 *
 * @param options - user provided options
 * @returns normalized options
 */
declare function resolveOptions(options: Options): ResolvedOptions;

export { DEFAULT_OPTIONS as D, Options as O, ResolvedOptions as R, ServerContext as S, TreeNode as T, _RoutesFolder as _, createTreeNodeValue as a, TreeNodeValueParam as b, createPrefixTree as c, TreeNodeValueStatic as d, RoutesFolderOption as e, RoutesFolder as f, _OptionsImportMode as g, resolveOptions as r };
