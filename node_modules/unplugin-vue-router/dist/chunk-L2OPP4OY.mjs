// src/core/utils.ts
import { pascalCase } from "scule";
function logTree(tree, log) {
  log(printTree(tree));
}
var MAX_LEVEL = 1e3;
function printTree(tree, level = 0, parentPre = "", treeStr = "") {
  if (typeof tree !== "object" || level >= MAX_LEVEL)
    return "";
  if (tree instanceof Map) {
    const total = tree.size;
    let index = 0;
    for (const [_key, child] of tree) {
      const hasNext = index++ < total - 1;
      const { children } = child;
      treeStr += `${`${parentPre}${hasNext ? "\u251C" : "\u2514"}\u2500\u2500 `}${child}
`;
      if (children) {
        treeStr += printTree(
          children,
          level + 1,
          `${parentPre}${hasNext ? "\u2502" : " "}   `
        );
      }
    }
  } else {
    const children = tree.children;
    treeStr = `${tree}
`;
    if (children) {
      treeStr += printTree(children, level + 1);
    }
  }
  return treeStr;
}
var isArray = Array.isArray;
function trimExtension(path) {
  const lastDot = path.lastIndexOf(".");
  return lastDot < 0 ? path : path.slice(0, lastDot);
}
function throttle(fn, wait, initialWait) {
  let pendingExecutionTimeout = null;
  let pendingExecution = false;
  let executionTimeout = null;
  return () => {
    if (pendingExecutionTimeout == null) {
      pendingExecutionTimeout = setTimeout(() => {
        pendingExecutionTimeout = null;
        if (pendingExecution) {
          pendingExecution = false;
          fn();
        }
      }, wait);
      executionTimeout = setTimeout(() => {
        executionTimeout = null;
        fn();
      }, initialWait);
    } else if (executionTimeout == null) {
      pendingExecution = true;
    }
  };
}
var LEADING_SLASH_RE = /^\//;
var TRAILING_SLASH_RE = /\/$/;
function joinPath(...paths) {
  let result = "";
  for (const path of paths) {
    result = result.replace(TRAILING_SLASH_RE, "") + (path && "/" + path.replace(LEADING_SLASH_RE, ""));
  }
  return result;
}
function paramToName({ paramName, modifier, isSplat }) {
  return `${isSplat ? "$" : ""}${paramName.charAt(0).toUpperCase() + paramName.slice(1)}${modifier}`;
}
function getPascalCaseRouteName(node) {
  var _a;
  if (((_a = node.parent) == null ? void 0 : _a.isRoot()) && node.value.pathSegment === "")
    return "Root";
  let name = node.value.subSegments.map((segment) => {
    if (typeof segment === "string") {
      return pascalCase(segment);
    }
    return paramToName(segment);
  }).join("");
  if (node.value.filePaths.size && node.children.has("index")) {
    name += "Parent";
  }
  const parent = node.parent;
  return (parent && !parent.isRoot() ? getPascalCaseRouteName(parent).replace(/Parent$/, "") : "") + name;
}
function getFileBasedRouteName(node) {
  if (!node.parent)
    return "";
  return getFileBasedRouteName(node.parent) + "/" + node.value.rawSegment;
}
function mergeRouteRecordOverride(a, b) {
  const merged = {};
  const keys = [
    .../* @__PURE__ */ new Set([
      ...Object.keys(a),
      ...Object.keys(b)
    ])
  ];
  for (const key of keys) {
    if (key === "alias") {
      merged[key] = [...a[key] || [], ...b[key] || []];
    } else if (key === "meta") {
      merged[key] = mergeDeep(a[key] || {}, b[key] || {});
    } else {
      merged[key] = b[key] ?? a[key];
    }
  }
  return merged;
}
function isObject(obj) {
  return obj && typeof obj === "object";
}
function mergeDeep(...objects) {
  return objects.reduce((prev, obj) => {
    Object.keys(obj).forEach((key) => {
      const pVal = prev[key];
      const oVal = obj[key];
      if (Array.isArray(pVal) && Array.isArray(oVal)) {
        prev[key] = pVal.concat(...oVal);
      } else if (isObject(pVal) && isObject(oVal)) {
        prev[key] = mergeDeep(pVal, oVal);
      } else {
        prev[key] = oVal;
      }
    });
    return prev;
  }, {});
}
var __DEV__ = process.env.NODE_ENV !== "production";

export {
  logTree,
  isArray,
  trimExtension,
  throttle,
  joinPath,
  getPascalCaseRouteName,
  getFileBasedRouteName,
  mergeRouteRecordOverride,
  __DEV__
};
