import { T as TreeNode } from './options-dcd51c9e.js';
import { RouteParams, LocationQuery, RouteRecordName, RouteLocationNormalizedLoaded, Router } from 'vue-router';
import { Ref, UnwrapRef } from 'vue';

declare type Awaitable<T> = T | PromiseLike<T>;
declare type LiteralStringUnion<LiteralType, BaseType extends string = string> = LiteralType | (BaseType & Record<never, never>);
/**
 * Creates a name based of the node path segments.
 *
 * @param node - the node to get the path from
 * @param parent - the parent node
 * @returns a route name
 */
declare function getPascalCaseRouteName(node: TreeNode): string;
/**
 * Joins the path segments of a node into a name that corresponds to the filepath represented by the node.
 *
 * @param node - the node to get the path from
 * @returns a route name
 */
declare function getFileBasedRouteName(node: TreeNode): string;

interface DataLoaderCacheEntry<T = unknown, isLazy = boolean> {
    /**
     * When was the data loaded in ms (Date.now()).
     * @internal
     */
    when: number;
    params: Partial<RouteParams>;
    query: Partial<LocationQuery>;
    hash: string | null;
    loaders: Set<DataLoaderCacheEntry>;
    /**
     * Whether there is an ongoing request.
     */
    pending: Ref<boolean>;
    /**
     * Error if there was an error.
     */
    error: Ref<any>;
    isReady: boolean;
    /**
     * Data stored in the cache.
     */
    data: false extends isLazy ? Ref<UnwrapRef<T>> : Ref<UnwrapRef<T> | undefined>;
}
/**
 * Stop and invalidate the scope used for data. Note this will make any application stop working. It should be used only
 * if there is a need to manually stop a running application without stopping the process.
 */
declare function stopScope(): void;

interface DefineLoaderOptions<isLazy extends boolean = boolean> {
    /**
     * How long should we wait to consider the fetched data expired. Amount in ms. Defaults to 5 minutes. A value of 0
     * means no cache while a value of `Infinity` means cache forever.
     */
    cacheTime?: number;
    /**
     * Whether the data should be lazy loaded without blocking the navigation or not. Defaults to false. When set to true
     * or a function, the loader will no longer block the navigation and the returned composable can be called even
     * without having the data ready. This also means that the data will be available as one single `ref()` named `data`
     * instead of all the individual properties returned by the loader.
     */
    lazy?: isLazy;
    /**
     * SSR Key to store the data in an object that can be serialized later to the HTML page.
     */
    key?: string;
}
/**
 * Loader function that can be passed to `defineLoader()`.
 */
interface DefineLoaderFn<T> {
    (route: RouteLocationNormalizedLoaded): T extends Promise<any> ? T : Promise<T>;
}
declare function defineLoader<P extends Promise<any>, isLazy extends boolean = false>(name: RouteRecordName, loader: DefineLoaderFn<P>, options?: DefineLoaderOptions<isLazy>): DataLoader<Awaited<P>, isLazy>;
declare function defineLoader<P extends Promise<any>, isLazy extends boolean = false>(loader: DefineLoaderFn<P>, options?: DefineLoaderOptions<isLazy>): DataLoader<Awaited<P>, isLazy>;
declare const IsLoader: unique symbol;
declare type _PromiseMerged<T> = T & Promise<T>;
interface DataLoader<T, isLazy extends boolean = boolean> {
    (): _PromiseMerged<_DataLoaderResult<T, isLazy>>;
    [IsLoader]: true;
    /**
     * Internal context for the loader.
     * @internal
     */
    _: _DataLoaderInternals<T>;
}
/**
 * Holds internal state of a loader.
 *
 * @internal
 */
interface _DataLoaderInternals<T> {
    loader: (route: RouteLocationNormalizedLoaded) => Promise<T>;
    /**
     * Loads the data from the cache if possible, otherwise loads it from the loader and awaits it.
     */
    load: (route: RouteLocationNormalizedLoaded, router: Router, parent?: DataLoaderCacheEntry, initialRootData?: Record<string, unknown>) => Promise<void>;
    /**
     * The data loaded by the loader associated with the router instance. As one router instance can only be used for one
     * app, it ensures the cache is not shared among requests.
     */
    cache: WeakMap<Router, DataLoaderCacheEntry<T>>;
    /**
     * Resolved options for the loader.
     */
    options: Required<DefineLoaderOptions>;
}
interface _DataLoaderResult<T = unknown, isLazy = boolean> {
    /**
     * Whether there is an ongoing request.
     */
    pending: Ref<boolean>;
    /**
     * Error if there was an error.
     */
    error: Ref<any>;
    /**
     * Refresh the data. Returns a promise that resolves when the data is refreshed.
     */
    refresh: () => Promise<void>;
    /**
     * Invalidates the data so it is reloaded on the next request.
     */
    invalidate: () => void;
    /**
     * Get the promise of the current loader if there is one, returns a falsy value otherwise.
     */
    pendingLoad: () => Promise<void> | undefined | null;
    /**
     * Data returned by the loader.
     */
    data: false extends isLazy ? Ref<UnwrapRef<T>> : Ref<UnwrapRef<T> | undefined>;
}

export { Awaitable as A, DefineLoaderOptions as D, LiteralStringUnion as L, getPascalCaseRouteName as a, DataLoader as b, defineLoader as d, getFileBasedRouteName as g, stopScope as s };
