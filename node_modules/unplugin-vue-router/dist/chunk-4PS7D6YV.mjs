import {
  resolveOptions
} from "./chunk-Y3YJJQFJ.mjs";
import {
  joinPath,
  logTree,
  mergeRouteRecordOverride,
  throttle,
  trimExtension
} from "./chunk-L2OPP4OY.mjs";

// src/index.ts
import { createUnplugin } from "unplugin";

// src/core/treeNodeValue.ts
var _TreeNodeValueBase = class {
  constructor(rawSegment, parent, pathSegment = rawSegment, subSegments = [rawSegment]) {
    this._overrides = /* @__PURE__ */ new Map();
    this.includeLoaderGuard = false;
    this._type = 0;
    this.rawSegment = rawSegment;
    this.pathSegment = pathSegment;
    this.subSegments = subSegments;
    const parentPath = parent == null ? void 0 : parent.path;
    this.path = (!parentPath || parentPath === "/") && this.pathSegment === "" ? "/" : joinPath((parent == null ? void 0 : parent.path) || "", this.pathSegment);
    this.filePaths = /* @__PURE__ */ new Map();
  }
  toString() {
    return this.pathSegment || "<index>";
  }
  isParam() {
    return !!(this._type & 1 /* param */);
  }
  isStatic() {
    return this._type === 0 /* static */;
  }
  get overrides() {
    return [...this._overrides.entries()].sort(
      ([nameA], [nameB]) => nameA === nameB ? 0 : nameA < nameB ? -1 : 1
    ).reduce((acc, [_path, routeBlock]) => {
      return mergeRouteRecordOverride(acc, routeBlock);
    }, {});
  }
  setOverride(path, routeBlock) {
    this._overrides.set(path, routeBlock || {});
  }
};
var TreeNodeValueStatic = class extends _TreeNodeValueBase {
  constructor(rawSegment, parent, pathSegment = rawSegment) {
    super(rawSegment, parent, pathSegment);
    this._type = 0 /* static */;
  }
};
var TreeNodeValueParam = class extends _TreeNodeValueBase {
  constructor(rawSegment, parent, params, pathSegment, subSegments) {
    super(rawSegment, parent, pathSegment, subSegments);
    this._type = 1 /* param */;
    this.params = params;
  }
};
function createTreeNodeValue(segment, parent) {
  if (!segment || segment === "index") {
    return new TreeNodeValueStatic("", parent);
  }
  const [pathSegment, params, subSegments] = parseSegment(segment);
  if (params.length) {
    return new TreeNodeValueParam(
      segment,
      parent,
      params,
      pathSegment,
      subSegments
    );
  }
  return new TreeNodeValueStatic(segment, parent, pathSegment);
}
function parseSegment(segment) {
  let buffer = "";
  let state = 0 /* static */;
  const params = [];
  let pathSegment = "";
  const subSegments = [];
  let currentTreeRouteParam = createEmptyRouteParam();
  function consumeBuffer() {
    if (state === 0 /* static */) {
      pathSegment += buffer;
      subSegments.push(buffer);
    } else if (state === 3 /* modifier */) {
      currentTreeRouteParam.paramName = buffer;
      currentTreeRouteParam.modifier = currentTreeRouteParam.optional ? currentTreeRouteParam.repeatable ? "*" : "?" : currentTreeRouteParam.repeatable ? "+" : "";
      buffer = "";
      pathSegment += `:${currentTreeRouteParam.paramName}${currentTreeRouteParam.isSplat ? "(.*)" : ""}${currentTreeRouteParam.modifier}`;
      params.push(currentTreeRouteParam);
      subSegments.push(currentTreeRouteParam);
      currentTreeRouteParam = createEmptyRouteParam();
    }
    buffer = "";
  }
  for (let pos = 0; pos < segment.length; pos++) {
    const c = segment[pos];
    if (state === 0 /* static */) {
      if (c === "[") {
        consumeBuffer();
        state = 1 /* paramOptional */;
      } else {
        buffer += c === "." ? "/" : c;
      }
    } else if (state === 1 /* paramOptional */) {
      if (c === "[") {
        currentTreeRouteParam.optional = true;
      } else if (c === ".") {
        currentTreeRouteParam.isSplat = true;
        pos += 2;
      } else {
        buffer += c;
      }
      state = 2 /* param */;
    } else if (state === 2 /* param */) {
      if (c === "]") {
        if (currentTreeRouteParam.optional) {
          pos++;
        }
        state = 3 /* modifier */;
      } else if (c === ".") {
        currentTreeRouteParam.isSplat = true;
        pos += 2;
      } else {
        buffer += c;
      }
    } else if (state === 3 /* modifier */) {
      if (c === "+") {
        currentTreeRouteParam.repeatable = true;
      } else {
        pos--;
      }
      consumeBuffer();
      state = 0 /* static */;
    }
  }
  if (state === 2 /* param */ || state === 1 /* paramOptional */) {
    throw new Error(`Invalid segment: "${segment}"`);
  }
  if (buffer) {
    consumeBuffer();
  }
  return [pathSegment, params, subSegments];
}
function createEmptyRouteParam() {
  return {
    paramName: "",
    modifier: "",
    optional: false,
    repeatable: false,
    isSplat: false
  };
}

// src/core/tree.ts
var TreeNode = class {
  constructor(options, filePath, parent) {
    this.children = /* @__PURE__ */ new Map();
    this.hasDefinePage = false;
    this.options = options;
    this.parent = parent;
    this.value = createTreeNodeValue(filePath, parent == null ? void 0 : parent.value);
  }
  insert(path, filePath = path) {
    const { tail, segment, viewName, isComponent } = splitFilePath(path);
    if (!this.children.has(segment)) {
      this.children.set(segment, new TreeNode(this.options, segment, this));
    }
    const child = this.children.get(segment);
    if (isComponent) {
      child.value.filePaths.set(viewName, filePath);
    }
    if (tail) {
      return child.insert(tail, filePath);
    }
    return child;
  }
  setCustomRouteBlock(path, routeBlock) {
    this.value.setOverride(path, routeBlock);
  }
  getSortedChildren() {
    return Array.from(this.children.values()).sort(
      (a, b) => a.path.localeCompare(b.path)
    );
  }
  remove(path) {
    const { tail, segment, viewName, isComponent } = splitFilePath(path);
    const child = this.children.get(segment);
    if (!child) {
      throw new Error(
        `Cannot Delete "${path}". "${segment}" not found at "${this.path}".`
      );
    }
    if (tail) {
      child.remove(tail);
      if (child.children.size === 0 && child.value.filePaths.size === 0) {
        this.children.delete(segment);
      }
    } else {
      if (isComponent) {
        child.value.filePaths.delete(viewName);
      }
      if (child.children.size === 0 && child.value.filePaths.size === 0) {
        this.children.delete(segment);
      }
    }
  }
  get path() {
    var _a;
    return this.value.overrides.path ?? (((_a = this.parent) == null ? void 0 : _a.isRoot()) ? "/" : "") + this.value.pathSegment;
  }
  get fullPath() {
    return this.value.overrides.path ?? this.value.path;
  }
  get name() {
    return this.value.overrides.name || this.options.getRouteName(this);
  }
  get meta() {
    const overrideMeta = { ...this.value.overrides.meta };
    if (this.value.includeLoaderGuard) {
      overrideMeta._loaderGuard = true;
    }
    return Object.keys(overrideMeta).length > 0 ? JSON.stringify(overrideMeta, null, 2) : "";
  }
  get params() {
    const params = this.value.isParam() ? [...this.value.params] : [];
    let node = this.parent;
    while (node) {
      if (node.value.isParam()) {
        params.unshift(...node.value.params);
      }
      node = node.parent;
    }
    return params;
  }
  isRoot() {
    return this.value.path === "/" && !this.value.filePaths.size;
  }
  toString() {
    return `${this.value}${this.value.filePaths.size > 1 || this.value.filePaths.size === 1 && !this.value.filePaths.get("default") ? ` \u2388(${Array.from(this.value.filePaths.keys()).join(", ")})` : ""}${this.hasDefinePage ? " \u2691 definePage()" : ""}`;
  }
};
function createPrefixTree(options) {
  return new TreeNode(options, "");
}
function splitFilePath(filePath) {
  const slashPos = filePath.indexOf("/");
  let head = slashPos < 0 ? filePath : filePath.slice(0, slashPos);
  const tail = slashPos < 0 ? "" : filePath.slice(slashPos + 1);
  let segment = head;
  if (!tail) {
    segment = trimExtension(head);
  }
  let viewName = "default";
  const namedSeparatorPos = segment.indexOf("@");
  if (namedSeparatorPos > 0) {
    viewName = segment.slice(namedSeparatorPos + 1);
    segment = segment.slice(0, namedSeparatorPos);
  }
  const isComponent = segment !== head;
  return {
    segment,
    tail,
    viewName,
    isComponent
  };
}

// src/core/context.ts
import { promises as fs3 } from "fs";

// src/codegen/generateRouteParams.ts
function generateRouteParams(node, isRaw) {
  const nodeParams = node.params;
  return node.params.length > 0 ? `{ ${node.params.map(
    (param) => `${param.paramName}${param.optional ? "?" : ""}: ` + (param.modifier === "+" ? `ParamValueOneOrMore<${isRaw}>` : param.modifier === "*" ? `ParamValueZeroOrMore<${isRaw}>` : param.modifier === "?" ? `ParamValueZeroOrOne<${isRaw}>` : `ParamValue<${isRaw}>`)
  ).join(", ")} }` : "Record<never, never>";
}

// src/codegen/generateRouteMap.ts
function generateRouteNamedMap(node) {
  if (node.isRoot()) {
    return `export interface RouteNamedMap {
${node.getSortedChildren().map(generateRouteNamedMap).join("")}}`;
  }
  return (node.value.filePaths.size ? `  '${node.name}': ${generateRouteRecordInfo(node)},
` : "") + (node.children.size > 0 ? node.getSortedChildren().map(generateRouteNamedMap).join("\n") : "");
}
function generateRouteRecordInfo(node) {
  return `RouteRecordInfo<'${node.name}', '${node.fullPath}', ${generateRouteParams(node, true)}, ${generateRouteParams(node, false)}>`;
}

// src/core/moduleConstants.ts
var MODULE_VUE_ROUTER = "vue-router/auto";
var MODULE_ROUTES_PATH = `${MODULE_VUE_ROUTER}/routes`;
var VIRTUAL_PREFIX = "virtual:";
var ROUTE_BLOCK_ID = `${VIRTUAL_PREFIX}/vue-router/auto/route-block`;
function getVirtualId(id) {
  return id.startsWith(VIRTUAL_PREFIX) ? id.slice(VIRTUAL_PREFIX.length) : null;
}
var routeBlockQueryRE = /\?vue&type=route/;
function asVirtualId(id) {
  return VIRTUAL_PREFIX + id;
}

// src/codegen/generateRouteRecords.ts
function generateRouteRecord(node, options, importList, indent = 0) {
  if (node.value.path === "/" && indent === 0) {
    return `[
${node.getSortedChildren().map((child) => generateRouteRecord(child, options, importList, indent + 1)).join(",\n")}
]`;
  }
  const startIndent = " ".repeat(indent * 2);
  const indentStr = " ".repeat((indent + 1) * 2);
  const routeRecord = `${startIndent}{
${indentStr}path: '${node.path}',
${indentStr}${node.value.filePaths.size ? `name: '${node.name}',` : "/* no name */"}
${indentStr}${node.value.filePaths.size ? generateRouteRecordComponent(
    node,
    indentStr,
    options.importMode,
    importList
  ) : "/* no component */"}
${indentStr}${node.value.overrides.props != null ? `props: ${node.value.overrides.props},` : "/* no props */"}
${indentStr}${node.children.size > 0 ? `children: [
${node.getSortedChildren().map((child) => generateRouteRecord(child, options, importList, indent + 2)).join(",\n")}
${indentStr}],` : "/* no children */"}${formatMeta(node, indentStr)}
${startIndent}}`;
  if (node.hasDefinePage) {
    const definePageDataList = [];
    for (const [name, filePath] of node.value.filePaths) {
      const pageDataImport = `_definePage_${name}_${importList.size}`;
      definePageDataList.push(pageDataImport);
      importList.set(pageDataImport, `${filePath}?definePage&vue`);
    }
    if (definePageDataList.length) {
      return `  _mergeRouteRecord(
${routeRecord},
  ${definePageDataList.join(",\n")}
  )`;
    }
  }
  return routeRecord;
}
function generateRouteRecordComponent(node, indentStr, importMode, importList) {
  const files = Array.from(node.value.filePaths);
  const isDefaultExport = files.length === 1 && files[0][0] === "default";
  return isDefaultExport ? `component: ${generatePageImport(files[0][1], importMode, importList)},` : `components: {
${files.map(
    ([key, path]) => `${indentStr + "  "}'${key}': ${generatePageImport(
      path,
      importMode,
      importList
    )}`
  ).join(",\n")}
${indentStr}},`;
}
function generatePageImport(filepath, importMode, importList) {
  const mode = typeof importMode === "function" ? importMode(filepath) : importMode;
  if (mode === "async") {
    return `() => import('${filepath}')`;
  } else {
    const importName = `_page_${importList.size}`;
    importList.set(importName, filepath);
    return importName;
  }
}
function generateImportList(node, indentStr) {
  const files = Array.from(node.value.filePaths);
  return `[
${files.map(([_key, path]) => `${indentStr}  () => import('${path}')`).join(",\n")}
${indentStr}]`;
}
var LOADER_GUARD_RE = /['"]_loaderGuard['"]:.*$/;
function formatMeta(node, indent) {
  const meta = node.meta;
  const formatted = meta && meta.split("\n").map(
    (line) => indent + line.replace(
      LOADER_GUARD_RE,
      "[_HasDataLoaderMeta]: " + generateImportList(node, indent + "  ") + ","
    )
  ).join("\n");
  return formatted ? "\n" + indent + "meta: " + formatted.trimStart() : "";
}

// src/core/context.ts
import fg from "fast-glob";
import { resolve } from "pathe";

// src/core/customBlock.ts
import { parse } from "@vue/compiler-sfc";
import { promises as fs } from "fs";
import JSON5 from "json5";
import { parse as YAMLParser } from "yaml";
async function getRouteBlock(path, options) {
  const content = await fs.readFile(path, "utf8");
  const parsedSFC = await parse(content, { pad: "space" }).descriptor;
  const blockStr = parsedSFC == null ? void 0 : parsedSFC.customBlocks.find((b) => b.type === "route");
  if (!blockStr)
    return;
  let result = parseCustomBlock(blockStr, path, options);
  if (result) {
    if (result.path != null && !result.path.startsWith("/")) {
      console.error(`Overridden path must start with "/". Found in "${path}".`);
    }
  }
  return result;
}
function parseCustomBlock(block, filePath, options) {
  const lang = block.lang ?? options.routeBlockLang;
  if (lang === "json5") {
    try {
      return JSON5.parse(block.content);
    } catch (err) {
      console.error(
        `Invalid JSON5 format of <${block.type}> content in ${filePath}
${err.message}`
      );
    }
  } else if (lang === "json") {
    try {
      return JSON.parse(block.content);
    } catch (err) {
      console.error(
        `Invalid JSON format of <${block.type}> content in ${filePath}
${err.message}`
      );
    }
  } else if (lang === "yaml" || lang === "yml") {
    try {
      return YAMLParser(block.content);
    } catch (err) {
      console.error(
        `Invalid YAML format of <${block.type}> content in ${filePath}
${err.message}`
      );
    }
  } else {
    console.error(
      `\u26A0\uFE0F  unplugin-vue-router: Invalid "lang" of <${block.type}> in ${filePath}. Supported languages are: json5, json, yaml, yml.`
    );
  }
}

// src/core/RoutesFolderWatcher.ts
import chokidar from "chokidar";
import { normalize } from "pathe";
var RoutesFolderWatcher = class {
  constructor(routesFolder, options) {
    this.src = routesFolder.src;
    this.pathPrefix = routesFolder.path || "";
    this.options = options;
    this.watcher = chokidar.watch(this.src, {
      ignoreInitial: true,
      ignorePermissionErrors: true,
      ignored: options.exclude
    });
  }
  asRoutePath(path) {
    return this.pathPrefix + path.slice(this.src.length + 1);
  }
  on(event, handler) {
    this.watcher.on(event, (filePath) => {
      filePath = normalize(filePath);
      if (this.options.extensions.every(
        (extension) => !filePath.endsWith(extension)
      )) {
        return;
      }
      handler({
        filePath,
        routePath: this.asRoutePath(filePath)
      });
    });
    return this;
  }
  close() {
    this.watcher.close();
  }
};

// src/codegen/generateDTS.ts
function generateDTS({
  vueRouterModule,
  routesModule,
  routeNamedMap
}) {
  return `// Generated by unplugin-vue-router. \u203C\uFE0F DO NOT MODIFY THIS FILE \u203C\uFE0F
// It's recommended to commit this file.
// Make sure to add this file to your tsconfig.json file as an "includes" or "files" entry.

/// <reference types="unplugin-vue-router/client" />

import type {
  // type safe route locations
  RouteLocationTypedList,
  RouteLocationResolvedTypedList,
  RouteLocationNormalizedTypedList,
  RouteLocationNormalizedLoadedTypedList,
  RouteLocationAsString,
  RouteLocationAsRelativeTypedList,
  RouteLocationAsPathTypedList,

  // helper types
  // route definitions
  RouteRecordInfo,
  ParamValue,
  ParamValueOneOrMore,
  ParamValueZeroOrMore,
  ParamValueZeroOrOne,

  // vue-router extensions
  _RouterTyped,
  RouterLinkTyped,
  NavigationGuard,
  UseLinkFnTyped,

  // data fetching
  _DataLoader,
  _DefineLoaderOptions,
} from 'unplugin-vue-router'

declare module '${routesModule}' {
${routeNamedMap}
}

declare module '${vueRouterModule}' {
  import type { RouteNamedMap } from '${routesModule}'

  export type RouterTyped = _RouterTyped<RouteNamedMap>

  /**
   * Type safe version of \`RouteLocationNormalized\` (the type of \`to\` and \`from\` in navigation guards).
   * Allows passing the name of the route to be passed as a generic.
   */
  export type RouteLocationNormalized<Name extends keyof RouteNamedMap = keyof RouteNamedMap> = RouteLocationNormalizedTypedList<RouteNamedMap>[Name]

  /**
   * Type safe version of \`RouteLocationNormalizedLoaded\` (the return type of \`useRoute()\`).
   * Allows passing the name of the route to be passed as a generic.
   */
  export type RouteLocationNormalizedLoaded<Name extends keyof RouteNamedMap = keyof RouteNamedMap> = RouteLocationNormalizedLoadedTypedList<RouteNamedMap>[Name]

  /**
   * Type safe version of \`RouteLocationResolved\` (the returned route of \`router.resolve()\`).
   * Allows passing the name of the route to be passed as a generic.
   */
  export type RouteLocationResolved<Name extends keyof RouteNamedMap = keyof RouteNamedMap> = RouteLocationResolvedTypedList<RouteNamedMap>[Name]

  /**
   * Type safe version of \`RouteLocation\` . Allows passing the name of the route to be passed as a generic.
   */
  export type RouteLocation<Name extends keyof RouteNamedMap = keyof RouteNamedMap> = RouteLocationTypedList<RouteNamedMap>[Name]

  /**
   * Type safe version of \`RouteLocationRaw\` . Allows passing the name of the route to be passed as a generic.
   */
  export type RouteLocationRaw<Name extends keyof RouteNamedMap = keyof RouteNamedMap> =
    | RouteLocationAsString<RouteNamedMap>
    | RouteLocationAsRelativeTypedList<RouteNamedMap>[Name]
    | RouteLocationAsPathTypedList<RouteNamedMap>[Name]

  /**
   * Generate a type safe params for a route location. Requires the name of the route to be passed as a generic.
   */
  export type RouteParams<Name extends keyof RouteNamedMap> = RouteNamedMap[Name]['params']
  /**
   * Generate a type safe raw params for a route location. Requires the name of the route to be passed as a generic.
   */
  export type RouteParamsRaw<Name extends keyof RouteNamedMap> = RouteNamedMap[Name]['paramsRaw']

  export function useRouter(): RouterTyped
  export function useRoute<Name extends keyof RouteNamedMap = keyof RouteNamedMap>(name?: Name): RouteLocationNormalizedLoadedTypedList<RouteNamedMap>[Name]

  export const useLink: UseLinkFnTyped<RouteNamedMap>

  export function onBeforeRouteLeave(guard: NavigationGuard<RouteNamedMap>): void
  export function onBeforeRouteUpdate(guard: NavigationGuard<RouteNamedMap>): void

  // Experimental Data Fetching

  export function defineLoader<
    P extends Promise<any>,
    Name extends keyof RouteNamedMap = keyof RouteNamedMap,
    isLazy extends boolean = false,
  >(
    name: Name,
    loader: (route: RouteLocationNormalizedLoaded<Name>) => P,
    options?: _DefineLoaderOptions<isLazy>,
  ): _DataLoader<Awaited<P>, isLazy>
  export function defineLoader<
    P extends Promise<any>,
    isLazy extends boolean = false,
  >(
    loader: (route: RouteLocationNormalizedLoaded) => P,
    options?: _DefineLoaderOptions<isLazy>,
  ): _DataLoader<Awaited<P>, isLazy>

  export {
    _definePage as definePage,
    _HasDataLoaderMeta as HasDataLoaderMeta,
    _setupDataFetchingGuard as setupDataFetchingGuard,
    _stopDataFetchingScope as stopDataFetchingScope,
  } from 'unplugin-vue-router/runtime'
}

declare module 'vue-router' {
  import type { RouteNamedMap } from '${routesModule}'

  export interface TypesConfig {
    beforeRouteUpdate: NavigationGuard<RouteNamedMap>
    beforeRouteLeave: NavigationGuard<RouteNamedMap>

    $route: RouteLocationNormalizedLoadedTypedList<RouteNamedMap>[keyof RouteNamedMap]
    $router: _RouterTyped<RouteNamedMap>

    RouterLink: RouterLinkTyped<RouteNamedMap>
  }
}
`;
}

// src/codegen/vueRouterModule.ts
function generateVueRouterProxy(routesModule, options) {
  return `
import { routes } from '${routesModule}'
import { createRouter as _createRouter } from 'vue-router'

export * from 'vue-router'
export {
  _defineLoader as defineLoader,
  _definePage as definePage,
  _HasDataLoaderMeta as HasDataLoaderMeta,
  _setupDataFetchingGuard as setupDataFetchingGuard,
  _stopDataFetchingScope as stopDataFetchingScope,
} from 'unplugin-vue-router/runtime'

export function createRouter(options) {
  const { extendRoutes } = options
  // use Object.assign for better browser support
  const router = _createRouter(Object.assign(
    options,
    { routes: typeof extendRoutes === 'function' ? extendRoutes(routes) : routes },
  ))

  return router
}
`;
}

// src/data-fetching/parse.ts
import { promises as fs2 } from "fs";
import { findExports } from "mlly";
async function hasNamedExports(file) {
  const code = await fs2.readFile(file, "utf8");
  const exportedNames = findExports(code).filter(
    (e) => e.type !== "default" && e.type !== "star"
  );
  return exportedNames.length > 0;
}

// src/core/definePage.ts
import {
  getTransformResult,
  isCallOf,
  parseSFC,
  MagicString,
  checkInvalidScopeReference
} from "@vue-macros/common";
import { walkAST } from "ast-walker-scope";
var MACRO_DEFINE_PAGE = "definePage";
function definePageTransform({
  code,
  id
}) {
  if (!code.includes(MACRO_DEFINE_PAGE))
    return;
  const sfc = parseSFC(code, id);
  if (!sfc.scriptSetup)
    return;
  const { script, scriptSetup, scriptCompiled } = sfc;
  const definePageNodes = scriptCompiled.scriptSetupAst.map((node) => {
    if (node.type === "ExpressionStatement")
      node = node.expression;
    return isCallOf(node, MACRO_DEFINE_PAGE) ? node : null;
  }).filter((node) => !!node);
  if (!definePageNodes.length) {
    return;
  } else if (definePageNodes.length > 1) {
    throw new SyntaxError(`duplicate definePage() call`);
  }
  const definePageNode = definePageNodes[0];
  const setupOffset = scriptSetup.loc.start.offset;
  if (id.includes(MACRO_DEFINE_PAGE)) {
    const s = new MagicString(code);
    const routeRecord = definePageNode.arguments[0];
    const scriptBindings = sfc.scriptCompiled.scriptSetupAst ? getIdentifiers(sfc.scriptCompiled.scriptSetupAst) : [];
    checkInvalidScopeReference(routeRecord, MACRO_DEFINE_PAGE, scriptBindings);
    s.remove(setupOffset + routeRecord.end, code.length);
    s.remove(0, setupOffset + routeRecord.start);
    s.prepend(`export default `);
    return getTransformResult(s, id);
  } else {
    const s = new MagicString(code);
    s.remove(
      setupOffset + definePageNode.start,
      setupOffset + definePageNode.end
    );
    return getTransformResult(s, id);
  }
}
var getIdentifiers = (stmts) => {
  let ids = [];
  walkAST(
    {
      type: "Program",
      body: stmts,
      directives: [],
      sourceType: "module",
      sourceFile: ""
    },
    {
      enter(node) {
        if (node.type === "BlockStatement") {
          this.skip();
        }
      },
      leave(node) {
        if (node.type !== "Program")
          return;
        ids = Object.keys(this.scope);
      }
    }
  );
  return ids;
};

// src/core/context.ts
function createRoutesContext(options) {
  const { dts: preferDTS, root, routesFolder } = options;
  const dts = preferDTS === false ? false : preferDTS === true ? resolve(root, "typed-router.d.ts") : resolve(root, preferDTS);
  const routeTree = createPrefixTree(options);
  const routeMap = /* @__PURE__ */ new Map();
  function log(...args) {
    if (options.logs) {
      console.log(...args);
    }
  }
  const watchers = [];
  async function scanPages() {
    if (options.extensions.length < 1) {
      throw new Error(
        '"extensions" cannot be empty. Please specify at least one extension.'
      );
    }
    if (watchers.length > 0) {
      return;
    }
    const pattern = `**/*` + (options.extensions.length === 1 ? options.extensions[0] : `.{${options.extensions.map((extension) => extension.replace(".", "")).join(",")}}`);
    await Promise.all(
      routesFolder.map((folder) => {
        const watcher = new RoutesFolderWatcher(folder, options);
        setupWatcher(watcher);
        watchers.push(watcher);
        return fg(pattern, {
          cwd: folder.src,
          ignore: options.exclude
        }).then((files) => files.map((file) => resolve(folder.src, file))).then(
          (files) => Promise.all(
            files.map(
              (file) => addPage({
                routePath: watcher.asRoutePath(file),
                filePath: file
              })
            )
          )
        );
      })
    );
    await _writeConfigFiles();
  }
  async function addPage({ filePath: path, routePath }) {
    const routeBlock = await getRouteBlock(path, options);
    log(`added "${routePath}" for "${path}"`);
    if (routeBlock)
      log(routeBlock);
    const node = routeTree.insert(
      routePath,
      resolve(root, path)
    );
    node.setCustomRouteBlock(path, routeBlock);
    node.value.includeLoaderGuard = options.dataFetching && await hasNamedExports(path);
    routeMap.set(path, node);
    const content = await fs3.readFile(path, "utf8");
    node.hasDefinePage = content.includes("definePage");
  }
  async function updatePage({ filePath: path, routePath }) {
    log(`updated "${routePath}" for "${path}"`);
    const node = routeMap.get(path);
    if (!node) {
      console.warn(`Cannot update "${path}": Not found.`);
      return;
    }
    const content = await fs3.readFile(path, "utf8");
    node.hasDefinePage = content.includes("definePage");
    node.setCustomRouteBlock(path, await getRouteBlock(path, options));
    node.value.includeLoaderGuard = options.dataFetching && await hasNamedExports(path);
  }
  function removePage({ filePath: path, routePath }) {
    log(`remove "${routePath}" for "${path}"`);
    routeTree.remove(routePath);
    routeMap.delete(path);
  }
  function setupWatcher(watcher) {
    log(`\u{1F916} Scanning files in ${watcher.src}`);
    watcher.on("change", async (ctx) => {
      await updatePage(ctx);
      writeConfigFiles();
    }).on("add", async (ctx) => {
      await addPage(ctx);
      writeConfigFiles();
    }).on("unlink", async (ctx) => {
      await removePage(ctx);
      writeConfigFiles();
    });
  }
  function generateRoutes() {
    const importList = /* @__PURE__ */ new Map();
    const routesExport = `export const routes = ${generateRouteRecord(
      routeTree,
      options,
      importList
    )}`;
    let imports = "";
    if (true) {
      imports += `import { _HasDataLoaderMeta, _mergeRouteRecord } from 'unplugin-vue-router/runtime'
`;
    }
    for (const [name, path] of importList) {
      imports += `import ${name} from '${path}'
`;
    }
    if (imports) {
      imports += "\n";
    }
    return `${imports}${routesExport}
`;
  }
  function generateDTS2() {
    return generateDTS({
      vueRouterModule: MODULE_VUE_ROUTER,
      routesModule: MODULE_ROUTES_PATH,
      routeNamedMap: generateRouteNamedMap(routeTree).split("\n").filter((line) => line).map((line) => "  " + line).join("\n")
    });
  }
  function generateVueRouterProxy2() {
    return generateVueRouterProxy(MODULE_ROUTES_PATH, options);
  }
  let lastDTS;
  async function _writeConfigFiles() {
    log("writing");
    logTree(routeTree, log);
    if (dts) {
      const content = generateDTS2();
      if (lastDTS !== content) {
        await fs3.writeFile(dts, content, "utf-8");
        lastDTS = content;
        server == null ? void 0 : server.invalidate(MODULE_ROUTES_PATH);
        server == null ? void 0 : server.invalidate(MODULE_VUE_ROUTER);
        server == null ? void 0 : server.reload();
      }
    }
  }
  const writeConfigFiles = throttle(_writeConfigFiles, 500, 100);
  function stopWatcher() {
    watchers.forEach((watcher) => watcher.close());
  }
  let server;
  function setServerContext(_server) {
    server = _server;
  }
  return {
    scanPages,
    writeConfigFiles,
    setServerContext,
    stopWatcher,
    generateRoutes,
    generateVueRouterProxy: generateVueRouterProxy2,
    definePageTransform(code, id) {
      return definePageTransform({
        code,
        id
      });
    }
  };
}

// src/core/vite/index.ts
function createViteContext(server) {
  function invalidate(path) {
    const { moduleGraph } = server;
    const foundModule = moduleGraph.getModuleById(asVirtualId(path));
    if (foundModule) {
      moduleGraph.invalidateModule(foundModule);
    }
    return !!foundModule;
  }
  function reload() {
    if (server.ws) {
      server.ws.send({
        type: "full-reload",
        path: "*"
      });
    }
  }
  return {
    invalidate,
    reload
  };
}

// src/index.ts
import { createFilter } from "@rollup/pluginutils";
import { join } from "pathe";
var src_default = createUnplugin((opt = {}, meta) => {
  const options = resolveOptions(opt);
  const ctx = createRoutesContext(options);
  function getVirtualId2(id) {
    if (options._inspect)
      return id;
    return getVirtualId(id);
  }
  function asVirtualId2(id) {
    if (options._inspect)
      return id;
    return asVirtualId(id);
  }
  const pageFilePattern = `**/*` + (options.extensions.length === 1 ? options.extensions[0] : `.{${options.extensions.map((extension) => extension.replace(".", "")).join(",")}}`);
  const filterPageComponents = createFilter(
    [
      ...options.routesFolder.map(
        (routeOption) => join(routeOption.src, pageFilePattern)
      ),
      /definePage\&vue$/
    ],
    options.exclude
  );
  return {
    name: "unplugin-vue-router",
    enforce: "pre",
    resolveId(id) {
      if (id === MODULE_ROUTES_PATH) {
        return asVirtualId2(id);
      }
      if (id === MODULE_VUE_ROUTER) {
        return asVirtualId2(id);
      }
      if (routeBlockQueryRE.test(id)) {
        return ROUTE_BLOCK_ID;
      }
    },
    buildStart() {
      return ctx.scanPages();
    },
    buildEnd() {
      if (options.logs) {
        console.log("\u{1F6D1} stopping watcher");
      }
      ctx.stopWatcher();
    },
    transformInclude(id) {
      return filterPageComponents(id);
    },
    transform(code, id) {
      return ctx.definePageTransform(code, id);
    },
    load(id) {
      const resolvedId = getVirtualId2(id);
      if (resolvedId === MODULE_ROUTES_PATH) {
        return ctx.generateRoutes();
      }
      if (resolvedId === MODULE_VUE_ROUTER) {
        return ctx.generateVueRouterProxy();
      }
      if (id === ROUTE_BLOCK_ID) {
        return {
          code: `export default {}`,
          map: null
        };
      }
    },
    vite: {
      configureServer(server) {
        ctx.setServerContext(createViteContext(server));
      }
    }
  };
});
var VueRouterExports = [
  "useRoute",
  "useRouter",
  "defineLoader"
];
var VueRouterAutoImports = {
  "vue-router/auto": VueRouterExports,
  "unplugin-vue-router/runtime": [["_definePage", "definePage"]]
};

export {
  TreeNodeValueStatic,
  TreeNodeValueParam,
  createTreeNodeValue,
  TreeNode,
  createPrefixTree,
  createRoutesContext,
  src_default,
  VueRouterExports,
  VueRouterAutoImports
};
