{
  "version": 3,
  "sources": ["../../unplugin-vue-router/dist/chunk-L2OPP4OY.mjs", "../../unplugin-vue-router/dist/runtime.mjs"],
  "sourcesContent": ["// src/core/utils.ts\nimport { pascalCase } from \"scule\";\nfunction logTree(tree, log) {\n  log(printTree(tree));\n}\nvar MAX_LEVEL = 1e3;\nfunction printTree(tree, level = 0, parentPre = \"\", treeStr = \"\") {\n  if (typeof tree !== \"object\" || level >= MAX_LEVEL)\n    return \"\";\n  if (tree instanceof Map) {\n    const total = tree.size;\n    let index = 0;\n    for (const [_key, child] of tree) {\n      const hasNext = index++ < total - 1;\n      const { children } = child;\n      treeStr += `${`${parentPre}${hasNext ? \"\\u251C\" : \"\\u2514\"}\\u2500\\u2500 `}${child}\n`;\n      if (children) {\n        treeStr += printTree(\n          children,\n          level + 1,\n          `${parentPre}${hasNext ? \"\\u2502\" : \" \"}   `\n        );\n      }\n    }\n  } else {\n    const children = tree.children;\n    treeStr = `${tree}\n`;\n    if (children) {\n      treeStr += printTree(children, level + 1);\n    }\n  }\n  return treeStr;\n}\nvar isArray = Array.isArray;\nfunction trimExtension(path) {\n  const lastDot = path.lastIndexOf(\".\");\n  return lastDot < 0 ? path : path.slice(0, lastDot);\n}\nfunction throttle(fn, wait, initialWait) {\n  let pendingExecutionTimeout = null;\n  let pendingExecution = false;\n  let executionTimeout = null;\n  return () => {\n    if (pendingExecutionTimeout == null) {\n      pendingExecutionTimeout = setTimeout(() => {\n        pendingExecutionTimeout = null;\n        if (pendingExecution) {\n          pendingExecution = false;\n          fn();\n        }\n      }, wait);\n      executionTimeout = setTimeout(() => {\n        executionTimeout = null;\n        fn();\n      }, initialWait);\n    } else if (executionTimeout == null) {\n      pendingExecution = true;\n    }\n  };\n}\nvar LEADING_SLASH_RE = /^\\//;\nvar TRAILING_SLASH_RE = /\\/$/;\nfunction joinPath(...paths) {\n  let result = \"\";\n  for (const path of paths) {\n    result = result.replace(TRAILING_SLASH_RE, \"\") + (path && \"/\" + path.replace(LEADING_SLASH_RE, \"\"));\n  }\n  return result;\n}\nfunction paramToName({ paramName, modifier, isSplat }) {\n  return `${isSplat ? \"$\" : \"\"}${paramName.charAt(0).toUpperCase() + paramName.slice(1)}${modifier}`;\n}\nfunction getPascalCaseRouteName(node) {\n  var _a;\n  if (((_a = node.parent) == null ? void 0 : _a.isRoot()) && node.value.pathSegment === \"\")\n    return \"Root\";\n  let name = node.value.subSegments.map((segment) => {\n    if (typeof segment === \"string\") {\n      return pascalCase(segment);\n    }\n    return paramToName(segment);\n  }).join(\"\");\n  if (node.value.filePaths.size && node.children.has(\"index\")) {\n    name += \"Parent\";\n  }\n  const parent = node.parent;\n  return (parent && !parent.isRoot() ? getPascalCaseRouteName(parent).replace(/Parent$/, \"\") : \"\") + name;\n}\nfunction getFileBasedRouteName(node) {\n  if (!node.parent)\n    return \"\";\n  return getFileBasedRouteName(node.parent) + \"/\" + node.value.rawSegment;\n}\nfunction mergeRouteRecordOverride(a, b) {\n  const merged = {};\n  const keys = [\n    .../* @__PURE__ */ new Set([\n      ...Object.keys(a),\n      ...Object.keys(b)\n    ])\n  ];\n  for (const key of keys) {\n    if (key === \"alias\") {\n      merged[key] = [...a[key] || [], ...b[key] || []];\n    } else if (key === \"meta\") {\n      merged[key] = mergeDeep(a[key] || {}, b[key] || {});\n    } else {\n      merged[key] = b[key] ?? a[key];\n    }\n  }\n  return merged;\n}\nfunction isObject(obj) {\n  return obj && typeof obj === \"object\";\n}\nfunction mergeDeep(...objects) {\n  return objects.reduce((prev, obj) => {\n    Object.keys(obj).forEach((key) => {\n      const pVal = prev[key];\n      const oVal = obj[key];\n      if (Array.isArray(pVal) && Array.isArray(oVal)) {\n        prev[key] = pVal.concat(...oVal);\n      } else if (isObject(pVal) && isObject(oVal)) {\n        prev[key] = mergeDeep(pVal, oVal);\n      } else {\n        prev[key] = oVal;\n      }\n    });\n    return prev;\n  }, {});\n}\nvar __DEV__ = process.env.NODE_ENV !== \"production\";\n\nexport {\n  logTree,\n  isArray,\n  trimExtension,\n  throttle,\n  joinPath,\n  getPascalCaseRouteName,\n  getFileBasedRouteName,\n  mergeRouteRecordOverride,\n  __DEV__\n};\n", "import {\n  __DEV__\n} from \"./chunk-L2OPP4OY.mjs\";\n\n// src/data-fetching/defineLoader.ts\nimport {\n  useRouter,\n  useRoute\n} from \"vue-router\";\n\n// src/data-fetching/dataCache.ts\nimport { ref, effectScope } from \"vue\";\nfunction isCacheExpired(entry, options) {\n  const { cacheTime } = options;\n  return !cacheTime || Date.now() - entry.when >= cacheTime || Array.from(entry.loaders).some(\n    (childEntry) => isCacheExpired(childEntry, options)\n  );\n}\nfunction createDataCacheEntry(options, initialData) {\n  return withinScope(() => ({\n    pending: ref(false),\n    error: ref(),\n    when: Date.now(),\n    loaders: /* @__PURE__ */ new Set(),\n    data: ref(initialData),\n    params: {},\n    query: {},\n    isReady: false\n  }));\n}\nfunction updateDataCacheEntry(entry, data, params, query, hash) {\n  entry.when = Date.now();\n  entry.params = params;\n  entry.query = query;\n  entry.hash = hash.v;\n  entry.isReady = true;\n  entry.data.value = data;\n}\nvar scope;\nfunction withinScope(fn) {\n  return (scope = scope || effectScope(true)).run(fn);\n}\nfunction stopScope() {\n  if (scope) {\n    scope.stop();\n    scope = void 0;\n  }\n}\nvar currentContext;\nfunction getCurrentContext() {\n  return currentContext || [];\n}\nfunction setCurrentContext(context) {\n  currentContext = context;\n}\n\n// src/data-fetching/locationUtils.ts\nfunction includesParams(outer, inner) {\n  for (const key in inner) {\n    const innerValue = inner[key];\n    const outerValue = outer[key];\n    if (typeof innerValue === \"string\") {\n      if (innerValue !== outerValue)\n        return false;\n    } else if (!innerValue || !outerValue) {\n      if (innerValue !== outerValue)\n        return false;\n    } else {\n      if (!Array.isArray(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i) => value !== outerValue[i]))\n        return false;\n    }\n  }\n  return true;\n}\n\n// src/data-fetching/defineLoader.ts\nvar DEFAULT_DEFINE_LOADER_OPTIONS = {\n  cacheTime: 1e3 * 5,\n  lazy: false,\n  key: \"\"\n};\nfunction defineLoader(nameOrLoader, _loaderOrOptions, opts) {\n  const loader = typeof nameOrLoader === \"function\" ? nameOrLoader : _loaderOrOptions;\n  opts = typeof _loaderOrOptions === \"object\" ? _loaderOrOptions : opts;\n  const options = { ...DEFAULT_DEFINE_LOADER_OPTIONS, ...opts };\n  const dataLoader = () => {\n    let [parentEntry, _router, _route] = getCurrentContext();\n    const router = _router || useRouter();\n    const route = _route || useRoute();\n    if (!cache.has(router) || parentEntry) {\n      load(route, router, parentEntry);\n    }\n    const entry = cache.get(router);\n    const promise = Promise.resolve(pendingPromise).then(() => dataLoaderResult).finally(() => {\n      if (parentEntry) {\n        parentEntry.loaders.add(entry);\n      }\n      setCurrentContext(parentEntry && [parentEntry, router, route]);\n    });\n    const { data, pending, error } = entry;\n    function refresh() {\n      invalidate();\n      load(route, router, parentEntry);\n      return pendingPromise.catch(() => {\n      });\n    }\n    function invalidate() {\n      entry.when = 0;\n    }\n    const dataLoaderResult = {\n      data,\n      pending,\n      error,\n      refresh,\n      invalidate,\n      pendingLoad\n    };\n    return Object.assign(promise, dataLoaderResult);\n  };\n  const cache = /* @__PURE__ */ new WeakMap();\n  let pendingPromise;\n  let currentNavigation;\n  const pendingLoad = () => pendingPromise;\n  function load(route, router, parent, initialRootData) {\n    const hasCacheEntry = cache.has(router);\n    const initialData = initialRootData && initialRootData[options.key];\n    if (!hasCacheEntry) {\n      cache.set(router, createDataCacheEntry(options, initialData));\n    }\n    const entry = cache.get(router);\n    if (initialData) {\n      entry.when = 0;\n      return Promise.resolve();\n    }\n    const needsNewLoad = !hasCacheEntry || shouldFetchAgain(entry, route);\n    const { isReady, pending, error } = entry;\n    const { lazy } = options;\n    const isExpired = isCacheExpired(entry, options);\n    if (pendingPromise && !needsNewLoad && currentNavigation === route && (!isReady || !isExpired)) {\n      return lazy ? Promise.resolve() : pendingPromise;\n    }\n    if (needsNewLoad || !isReady && currentNavigation !== route || isReady && isExpired) {\n      pending.value = true;\n      error.value = null;\n      currentNavigation = route;\n      const [trackedRoute, params, query, hash] = trackRoute(route);\n      if (!pendingPromise) {\n        setCurrentContext([entry, router, route]);\n      }\n      const thisPromise = pendingPromise = loader(trackedRoute).then((data) => {\n        if (pendingPromise === thisPromise) {\n          updateDataCacheEntry(entry, data, params, query, hash);\n        }\n      }).catch((err) => {\n        error.value = err;\n        return Promise.reject(err);\n      }).finally(() => {\n        if (pendingPromise === thisPromise) {\n          pendingPromise = null;\n          pending.value = false;\n        }\n        setCurrentContext(parent && [parent, router, route]);\n      });\n    }\n    return lazy || !pendingPromise ? Promise.resolve() : pendingPromise;\n  }\n  dataLoader._ = {\n    loader,\n    cache,\n    load,\n    options\n  };\n  dataLoader[IsLoader] = true;\n  return dataLoader;\n}\nfunction shouldFetchAgain(entry, route) {\n  return !entry.when || !includesParams(route.params, entry.params) || !includesParams(route.query, entry.query) || entry.hash != null && entry.hash !== route.hash || Array.from(entry.loaders).some(\n    (childEntry) => shouldFetchAgain(childEntry, route)\n  );\n}\nvar IsLoader = Symbol();\nfunction isDataLoader(loader) {\n  return loader && loader[IsLoader];\n}\nfunction trackRoute(route) {\n  const [params, paramReads] = trackObjectReads(route.params);\n  const [query, queryReads] = trackObjectReads(route.query);\n  let hash = { v: null };\n  return [\n    {\n      ...route,\n      get hash() {\n        return hash.v = route.hash;\n      },\n      params,\n      query\n    },\n    paramReads,\n    queryReads,\n    hash\n  ];\n}\nfunction trackObjectReads(obj) {\n  const reads = {};\n  return [\n    new Proxy(obj, {\n      get(target, p, receiver) {\n        const value = Reflect.get(target, p, receiver);\n        reads[p] = value;\n        return value;\n      }\n    }),\n    reads\n  ];\n}\n\n// src/data-fetching/dataFetchingGuard.ts\nvar HasDataLoaderMeta = Symbol();\nvar ADDED_SYMBOL = Symbol();\nfunction setupDataFetchingGuard(router, { initialData } = {}) {\n  if (__DEV__) {\n    if (ADDED_SYMBOL in router) {\n      console.warn(\n        \"[vue-router]: Data fetching guard added twice. Make sure to remove the extra call.\"\n      );\n      return;\n    }\n    router[ADDED_SYMBOL] = true;\n  }\n  const fetchedState = {};\n  let isFetched;\n  router.beforeEach((to) => {\n    return Promise.all(\n      to.matched.flatMap((route) => route.meta[HasDataLoaderMeta]).filter((moduleImport) => moduleImport).map(\n        (moduleImport) => moduleImport().then((mod) => {\n          const loaders = Object.keys(mod).filter((exportName) => isDataLoader(mod[exportName])).map((loaderName) => mod[loaderName]);\n          return Promise.all(\n            loaders.map((loader) => {\n              const {\n                options: { key },\n                cache\n              } = loader._;\n              return loader._.load(\n                to,\n                router,\n                void 0,\n                initialData\n              ).then(() => {\n                if (!initialData) {\n                  if (key) {\n                    fetchedState[key] = cache.get(router).data.value;\n                  }\n                } else if (__DEV__ && !key && !isFetched) {\n                }\n              });\n            })\n          );\n        })\n      )\n    ).then(() => {\n      initialData = void 0;\n      isFetched = true;\n    });\n  });\n  return initialData ? null : fetchedState;\n}\n\n// src/runtime.ts\nvar _definePage = (route) => route;\nfunction _mergeRouteRecord(main, ...routeRecords) {\n  return routeRecords.reduce((acc, routeRecord) => {\n    const meta = Object.assign({}, acc.meta, routeRecord.meta);\n    Object.assign(acc, routeRecord);\n    acc.meta = meta;\n    return acc;\n  }, main);\n}\nexport {\n  HasDataLoaderMeta as _HasDataLoaderMeta,\n  defineLoader as _defineLoader,\n  _definePage,\n  _mergeRouteRecord,\n  setupDataFetchingGuard as _setupDataFetchingGuard,\n  stopScope as _stopDataFetchingScope\n};\n"],
  "mappings": "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",
  "names": []
}
