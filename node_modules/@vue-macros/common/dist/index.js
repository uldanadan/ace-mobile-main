"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }// src/vue.ts
var _compilersfc = require('@vue/compiler-sfc');
var parseSFC = (code, id) => {
  var _a;
  const { descriptor } = _compilersfc.parse.call(void 0, code, {
    filename: id
  });
  const lang = (_a = descriptor.script || descriptor.scriptSetup) == null ? void 0 : _a.lang;
  let scriptCompiled;
  return {
    ...descriptor,
    lang,
    get scriptCompiled() {
      if (scriptCompiled)
        return scriptCompiled;
      return scriptCompiled = _compilersfc.compileScript.call(void 0, descriptor, {
        id
      });
    }
  };
};
var addNormalScript = ({ script, lang }, s) => {
  return {
    start() {
      if (script)
        return script.loc.end.offset;
      const attrs = lang ? ` lang="${lang}"` : "";
      s.prependLeft(0, `<script${attrs}>`);
      return 0;
    },
    end() {
      if (!script)
        s.appendRight(0, `
<\/script>
`);
    }
  };
};

// src/ast.ts
var _path = require('path'); var _path2 = _interopRequireDefault(_path);


// src/constants.ts
var DEFINE_PROPS = "defineProps";
var DEFINE_EMITS = "defineEmits";
var DEFINE_OPTIONS = "defineOptions";
var DEFINE_MODEL = "defineModel";
var DEFINE_SETUP_COMPONENT = "defineSetupComponent";
var DEFINE_RENDER = "defineRender";
var REPO_ISSUE_URL = "https://github.com/sxzz/unplugin-vue-macros/issues";
var MAGIC_COMMENT_STATIC = "hoist-static";

// src/ast.ts
function getLang(filename) {
  return _path2.default.extname(filename).replace(/^\./, "");
}
function babelParse(code, lang) {
  const plugins = [];
  if (lang) {
    if (/^[cm]?tsx?$/.test(lang))
      plugins.push("typescript");
    if (/^[cm]?[jt]sx$/.test(lang))
      plugins.push("jsx");
  }
  const { program } = _compilersfc.babelParse.call(void 0, code, {
    sourceType: "module",
    plugins
  });
  return program;
}
function isCallOf(node, test) {
  return !!(node && node.type === "CallExpression" && node.callee.type === "Identifier" && (typeof test === "string" ? node.callee.name === test : test(node.callee.name)));
}
function checkInvalidScopeReference(node, method, setupBindings) {
  if (!node)
    return;
  _compilersfc.walkIdentifiers.call(void 0, node, (id) => {
    if (setupBindings.includes(id.name))
      throw new SyntaxError(
        `\`${method}()\` in <script setup> cannot reference locally declared variables (${id.name}) because it will be hoisted outside of the setup() function.`
      );
  });
}
function isStaticExpression(node) {
  var _a;
  if ((_a = node.leadingComments) == null ? void 0 : _a.some(
    (comment) => comment.value.trim() === MAGIC_COMMENT_STATIC
  ))
    return true;
  switch (node.type) {
    case "UnaryExpression":
      return isStaticExpression(node.argument);
    case "LogicalExpression":
    case "BinaryExpression":
      return isStaticExpression(node.left) && isStaticExpression(node.right);
    case "ConditionalExpression":
      return isStaticExpression(node.test) && isStaticExpression(node.consequent) && isStaticExpression(node.alternate);
    case "SequenceExpression":
    case "TemplateLiteral":
      return node.expressions.every((expr) => isStaticExpression(expr));
    case "ParenthesizedExpression":
    case "TSNonNullExpression":
    case "TSAsExpression":
    case "TSTypeAssertion":
      return isStaticExpression(node.expression);
  }
  if (isLiteralType(node))
    return true;
  return false;
}
function isLiteralType(node) {
  return node.type.endsWith("Literal");
}

// src/magic-string.ts
var _magicstring = require('magic-string'); var _magicstring2 = _interopRequireDefault(_magicstring);
var MagicString = class extends _magicstring2.default {
  removeNode(node, { offset = 0 } = {}) {
    this.remove(offset + node.start, offset + node.end);
    return this;
  }
  moveNode(node, index, { offset = 0 } = {}) {
    this.move(offset + node.start, offset + node.end, index);
    return this;
  }
  sliceNode(node, { offset = 0 } = {}) {
    return this.slice(offset + node.start, offset + node.end);
  }
  overwriteNode(node, content, { offset = 0, ...options } = {}) {
    const _content = typeof content === "string" ? content : this.sliceNode(content);
    this.overwrite(offset + node.start, offset + node.end, _content, options);
    return this;
  }
};

// src/unplugin.ts
var getTransformResult = (s, id) => {
  if (s == null ? void 0 : s.hasChanged()) {
    return {
      code: s.toString(),
      get map() {
        return s.generateMap({
          source: id,
          includeContent: true,
          hires: true
        });
      }
    };
  }
};



















exports.DEFINE_EMITS = DEFINE_EMITS; exports.DEFINE_MODEL = DEFINE_MODEL; exports.DEFINE_OPTIONS = DEFINE_OPTIONS; exports.DEFINE_PROPS = DEFINE_PROPS; exports.DEFINE_RENDER = DEFINE_RENDER; exports.DEFINE_SETUP_COMPONENT = DEFINE_SETUP_COMPONENT; exports.MAGIC_COMMENT_STATIC = MAGIC_COMMENT_STATIC; exports.MagicString = MagicString; exports.REPO_ISSUE_URL = REPO_ISSUE_URL; exports.addNormalScript = addNormalScript; exports.babelParse = babelParse; exports.checkInvalidScopeReference = checkInvalidScopeReference; exports.getLang = getLang; exports.getTransformResult = getTransformResult; exports.isCallOf = isCallOf; exports.isLiteralType = isLiteralType; exports.isStaticExpression = isStaticExpression; exports.parseSFC = parseSFC;
